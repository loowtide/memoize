#! /usr/bin/env python3

import time
import datetime
from rich.table import Table
from rich.columns import Columns
from rich.panel import Panel
from rich import print
from rich.text import Text
from rich import box
from rich.console import Console
import csv
import argparse
from pathlib import Path
from dotenv import load_dotenv
import os
import getpass
import requests
import json

help_msg = """
"""


class Color:
    PURPLE = "\033[95m"
    CYAN = "\033[96m"
    BLUE = "\033[94m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    RED = "\033[91m"
    BOLD = "\033[1m"
    END = "\033[0m"


class Dashboard:
    """
    Dashboard for viewing progress
    """

    HEADER = """
▓▓▓    ▓▓▓ ▓▓▓▓▓▓▓ ▓▓▓    ▓▓▓  ▓▓▓▓▓▓  ▓▓ ▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓ 
▓▓▓▓  ▓▓▓▓ ▓▓      ▓▓▓▓  ▓▓▓▓ ▓▓    ▓▓ ▓▓    ▓▓▓  ▓▓      
▓▓ ▓▓▓▓ ▓▓ ▓▓▓▓▓   ▓▓ ▓▓▓▓ ▓▓ ▓▓    ▓▓ ▓▓   ▓▓▓   ▓▓▓▓▓   
▓▓  ▓▓  ▓▓ ▓▓      ▓▓  ▓▓  ▓▓ ▓▓    ▓▓ ▓▓  ▓▓▓    ▓▓      
▓▓      ▓▓ ▓▓▓▓▓▓▓ ▓▓      ▓▓  ▓▓▓▓▓▓  ▓▓ ▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓
                                                         v1.0
    """
    totalNum = 0
    revised = 0

    def __init__(self):
        self.console = Console()
        self.file_path = Setup.profile_path
        self.console.clear()
        self.draw_header()
        self.make_profile()
        self.count_revised()
        self.print_profile()
        self.count_revised()

    def draw_header(self):
        for line in self.HEADER.splitlines():
            self.console.print(f"[bold  red]{line}[/bold  red]")
            time.sleep(0.05)
        time.sleep(0.2)

    def make_profile(self):
        Setup()
        if not Setup.profile_path.exists():
            query = """
                        query getUserData($username: String!) {
                        profile: matchedUser(username: $username) {
                        username
                        profile {
                        ranking
                        realName
                        }
                        }
                        langs: matchedUser(username: $username) {
                        languageProblemCount {
                        languageName
                        problemsSolved
                            }
                        }
                        problems:matchedUser(username:$username){
                         problemsSolvedBeatsStats {
                          difficulty
                          percentage
                                    }   
                        submitStatsGlobal {
                          acSubmissionNum {
                            difficulty
                            count
                              }
                            }
                                }
                    }
                   """
            payload = {"query": query, "variables": {"username": Setup.USERNAME}}
            response = requests.post(
                Setup.url, cookies=Setup.cookie, headers=Setup.headers, json=payload
            )
            data = response.json().get("data", {})
            with open(Setup.profile_path, "w") as f:
                json.dump(data, f, indent=4)

    @classmethod
    def count_revised(cls):
        try:
            with open(Setup.csv_path, "r") as f:
                reader = csv.DictReader(f)
                next(reader)
                for row in reader:
                    cls.totalNum += 1
                    if row["revised"] == "Yes":
                        cls.revised += 1
            print(cls.revised)
        except FileNotFoundError as e:
            print(f"[bold red]File not found: {e}[/bold red]")

    def print_profile(self):
        with open(self.file_path, "r") as f:
            data = json.load(f)
            profile_info = data["profile"]

        try:
            mtime = os.path.getmtime(self.file_path)
            last_updated = datetime.datetime.fromtimestamp(mtime).strftime(
                "%Y-%m-%d %H:%M:%S"
            )

            with open(self.file_path, "r") as f:
                data = json.load(f)

        except FileNotFoundError:
            self.console.print(
                f"[bold red]Error:[/] File '{self.file_path}' not found."
            )
            return

        header_text = Text.assemble(
            ("User: ", "bold white"),
            (f"{profile_info['username']} ", "bold cyan"),
            ("| Ranking: ", "bold white"),
            (f"{profile_info['profile']['ranking']:,}", "bold yellow"),
        )
        self.console.print(Panel.fit(header_text, style="blue"))

        lang_table = Table(title="Languages Used", border_style="magenta")
        lang_table.add_column("Language", style="cyan")
        lang_table.add_column("Solved", style="green", justify="right")
        for lang in data["langs"]["languageProblemCount"]:
            lang_table.add_row(lang["languageName"], str(lang["problemsSolved"]))

        stats_table = Table(title="Difficulty Stats", border_style="green")
        stats_table.add_column("Difficulty", style="bold")
        stats_table.add_column("Solved", justify="right")
        stats_table.add_column("Beats %", justify="right")

        beats = {
            item["difficulty"]: item["percentage"]
            for item in data["problems"]["problemsSolvedBeatsStats"]
        }
        counts = {
            item["difficulty"]: item["count"]
            for item in data["problems"]["submitStatsGlobal"]["acSubmissionNum"]
        }

        for diff in ["Easy", "Medium", "Hard"]:
            pct_val = beats.get(diff)
            percentage = f"{pct_val}%" if pct_val is not None else "0%"
            count = str(counts.get(diff, 0))
            color = (
                "green" if diff == "Easy" else "yellow" if diff == "Medium" else "red"
            )
            stats_table.add_row(f"[{color}]{diff}[/]", count, percentage)

        revised_table = Table(title="Revised Questions", border_style="magenta")
        revised_table.add_column("Total", style="bold")
        revised_table.add_column("Revised", justify="right")
        revised_table.add_row(str(self.totalNum), str(self.revised))

        self.console.print(
            Columns([lang_table, stats_table, revised_table], equal=True)
        )

        footer_text = Text(
            f"Data Source: {self.file_path} | Last Updated: {last_updated}",
            style="dim italic white",
        )
        self.console.print(Panel.fit(footer_text, border_style="dim"))


class Questions:
    """Questions csv"""

    @classmethod
    def get_solved(cls):
        payload = {
            "query": "query userProgressQuestionList($filters: UserProgressQuestionListInput) { userProgressQuestionList(filters: $filters) { totalNum questions { frontendId title  titleSlug questionStatus } } }",
            "variables": {"filters": {"skip": 0, "limit": 1000}},
        }
        response = requests.post(
            Setup.url, cookies=Setup.cookie, headers=Setup.headers, json=payload
        )
        data = response.json()
        listing = data.get("data", {}).get("userProgressQuestionList", {})
        questions = listing["questions"]
        num = Setup.num
        cls.__make_csv(num, questions)

    @staticmethod
    def __make_csv(num, question):
        file_path = Setup.create_columns()
        ids = set()
        if os.path.exists(file_path):
            with open(file_path, "r", encoding="utf-8") as f:
                reader = csv.DictReader(f)
                for row in reader:
                    ids.add(row.get("frontendId"))

        if os.path.exists(file_path):
            with open(file_path, "a", newline="", encoding="utf-8") as f:
                writer = csv.DictWriter(f, Setup.columns, extrasaction="ignore")
                for record in question:
                    if (
                        record["questionStatus"] == "SOLVED"
                        and record["frontendId"] not in ids
                    ):
                        row = record.copy()
                        row["link"] = f"https://leetcode.com/{row['titleSlug']}"
                        row["priority"] = str(num)
                        num -= 1
                        row["notes"] = ""
                        row["revised"] = "No"
                        writer.writerow(row)


class Reminder:
    """
    Remind each to revise for a daily question
    """

    def __init__(self):
        self.__get_question()

    @staticmethod
    def __get_question():
        rows = []
        with open(Setup.csv_path, "r", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            rows = list(reader)
        target_rows = [r for r in rows if r.get("revised") == "No"]
        if not target_rows:
            print("[bold red]No data found[/bold red]")
            return
        min_row = min(target_rows, key=lambda x: int(x.get("priority")))
        title = min_row["title"]
        link = min_row["link"]
        min_row["revised"] = "Yes"
        min_row["priority"] = str(int(min_row["priority"]) + 1)
        print(
            Panel.fit(
                Text("Today's Question:\n")
                + Text(f"Title: {title}\n", style="green")
                + Text(f"Link:{link}", style="purple"),
                style="bold red",
                box=box.SQUARE,
            )
        )
        with open(Setup.csv_path, "w", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, Setup.columns)
            writer.writeheader()
            writer.writerows(rows)


class Notes:
    """
    Adding notes to LeetCode questions
    """

    def __init__(self):
        Questions.get_solved()
        self.add_notes_last()

    def add_notes_last(self):
        notes = input(f"{Color.GREEN}Enter notes{Color.END}")
        rows = []
        fieldnames = []
        with open(Setup.csv_path, "r", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            rows = list(reader)

        if rows:
            rows[0]["notes"] = notes
        with open(Setup.csv_path, "w", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, fieldnames=Setup.columns)
            writer.writeheader()
            writer.writerows(rows)


class Setup:
    base_dir = os.path.dirname(os.path.abspath(__file__))
    csv_path = Path(os.path.join(base_dir, "leetnotes.csv"))
    profile_path = Path(os.path.join(base_dir, "profile.json"))
    columns = ["frontendId", "title", "link", "notes", "priority", "revised"]
    num = None

    USERNAME = None
    LEETCODE_SESSION = None
    csrftoken = None
    url = None
    cookie = None
    headers = None

    def __init__(self):
        self.init_env()
        self.make_request()
        self.create_columns()

    @classmethod
    def make_request(cls):
        cls.url = "https://leetcode.com/graphql"
        cls.cookie = {
            "LEETCODE_SESSION": Setup.LEETCODE_SESSION,
            "csrftoken": Setup.csrftoken,
        }
        cls.headers = {
            "Content-Type": "application/json",
            "Referer": "https://leetcode.com",
            "X-CSRFToken": Setup.csrftoken,
        }

    @classmethod
    def create_columns(cls):
        if not cls.csv_path.exists():
            with open(cls.csv_path, "w", newline="", encoding="utf-8") as f:
                writer = csv.DictWriter(f, Setup.columns)
                writer.writeheader()
        return cls.csv_path

    @classmethod
    def init_env(cls):
        env_path = Path(__file__).resolve().parent / ".env"
        if env_path.exists():
            load_dotenv(dotenv_path=env_path)
            cls.LEETCODE_SESSION = os.getenv("LEETCODE_SESSION")
            cls.csrftoken = os.getenv("csrftoken")
            cls.USERNAME = os.getenv("USERNAME")
        else:
            session = getpass.getpass(
                f"{Color.BOLD}{Color.GREEN}Enter LEETCODE_SESSION:{Color.END}\n"
            )
            token = getpass.getpass(
                f"{Color.BOLD}{Color.GREEN}Enter csrftoken:{Color.END}\n"
            )
            username = input(f"{Color.BLUE}Enter username:\n{Color.END}")
            with open(env_path, "w") as f:
                f.write(f'LEETCODE_SESSION="{session}"\n')
                f.write(f'csrftoken="{token}"\n')
                f.write(f'USERNAME="{username}"\n')
            cls.LEETCODE_SESSION = session
            cls.csrftoken = token
            cls.USERNAME = username


def main():
    parser = argparse.ArgumentParser(add_help=True)
    subparser = parser.add_subparsers(dest="command")
    subparser.add_parser("dashboard", help="Open Dashboard")
    subparser.add_parser("note", help="Open last accepted question for notes")
    parser.add_argument("-d", "--dashboard", action="store_true")
    parser.add_argument("-n", "--note", action="store_true")
    args = parser.parse_args()
    if any([args.command == "dahboard", args.dashboard]):
        Dashboard()


if __name__ == "__main__":
    main()
